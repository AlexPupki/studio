# ADR 6: Архитектурный ландшафт проекта (Next.js + Payload CMS)

- **Дата**: 2024-08-25
- **Статус**: Accepted
- **Автор**: AI ассистент

## 1. Контекст

После принятия решения об использовании **Payload CMS** в качестве Headless CMS (см. [ADR по выбору CMS](../ui_playbook.md)), необходимо формализовать и визуализировать архитектуру всего проекта. Этот документ служит единым источником правды для всей команды (разработчиков, DevOps, технических писателей) о том, как компоненты системы взаимодействуют друг с другом.

## 2. Архитектура: Общая схема

Мы строим систему по принципу **модульного монолита** с четким разделением на два основных приложения:

1.  **`apps/web` (Next.js):** Публичный сайт и бизнес-логика. Отвечает за то, что видит конечный пользователь, и за обработку бизнес-процессов (бронирования, слоты и т.д.).
2.  **`apps/cms` (Payload CMS):** "Движок" для управления контентом. Предоставляет админ-панель для редакторов и API для доступа к контенту.

Оба приложения работают с общей базой данных **PostgreSQL** и общим файловым хранилищем **S3/GCS**.

### 2.1. Диаграмма взаимодействия

```mermaid
graph TD
    subgraph "Интернет"
        U[Пользователи]
        E[Редакторы]
    end

    subgraph "Инфраструктура (Один VPS или Cloud Run)"
        subgraph "Docker-контейнеры"
            WEB[<b>apps/web (Next.js)</b><br>Порт: 3000<br><i>Рендеринг и бизнес-логика</i>]
            CMS[<b>apps/cms (Payload)</b><br>Порт: 3001<br><i>Админка и Content API</i>]
        end

        NGINX[Веб-сервер / Reverse Proxy<br>(Nginx, Caddy, Traefik)]

        subgraph "Общие ресурсы"
            DB[(PostgreSQL)]
            S3[(S3/GCS Bucket)]
        end
    end

    U -- "vash-site.com" --> NGINX -- "Запросы на сайт" --> WEB
    E -- "admin.vash-site.com" --> NGINX -- "Запросы в админку" --> CMS

    WEB -- "Читает напрямую" --> DB
    WEB -- "Загружает файлы" --> S3

    CMS -- "CRUD операции" --> DB
    CMS -- "Управляет файлами" --> S3
    CMS -- "Вебхук (revalidate)" --> WEB
```

## 3. Как это работает на практике

### 3.1. Локальная разработка

- В корне проекта мы используем **pnpm workspaces** для управления двумя приложениями.
- Запускаем два процесса одновременно:
  - `pnpm dev:web` — запускает Next.js приложение на `http://localhost:3000`.
  - `pnpm dev:cms` — запускает Payload CMS на `http://localhost:3001`.
- Оба приложения подключаются к **одной и той же локальной базе данных PostgreSQL**.

### 3.2. Production (развертывание)

- **Коллега прав:** в production-среде мы будем использовать **Docker**.
- Каждое приложение (`web` и `cms`) упаковывается в свой собственный Docker-контейнер.
- Оба контейнера разворачиваются на **одном VPS** (или как два отдельных сервиса в Google Cloud Run).
- **Nginx** (или другой reverse proxy) настраивается для маршрутизации трафика:
  - домен `grandtoursochi.com` будет направлен на контейнер с Next.js.
  - поддомен `admin.grandtoursochi.com` будет направлен на контейнер с Payload CMS.

### 3.4. Взаимодействие с данными

- **Бизнес-данные** (бронирования, пользователи, слоты) управляются кодом в `apps/web` через **Drizzle ORM**.
- **Контентные данные** (страницы, посты, медиа) управляются через админ-панель **Payload CMS**.
- **Чтение контента:** Наше Next.js приложение для максимальной производительности будет читать данные напрямую из таблиц PostgreSQL, которые создает и которыми управляет Payload. Это избавляет нас от лишних сетевых запросов между приложениями.

## 4. Вывод для коллеги

- **Да, Payload будет жить в Docker-контейнере**, как и наше основное Next.js приложение.
- **Вам не нужен отдельный второй сервер** для Payload. Оба приложения могут эффективно работать на одном сервере.
- **Payload — это наша админ-панель и API для контента.** Next.js — это публичный сайт, который эти данные отображает. Они работают в паре, но являются независимыми приложениями.

Этот документ должен дать полное понимание нашей архитектуры. Если что-то осталось неясным, мы готовы это обсудить.
