# План системы логирования

Этот документ описывает архитектуру и план реализации системы логирования для приложения.

## 1. Основные требования

- **Централизованный модуль**: Единый сервис `src/lib/logger.ts`.
- **Уровни логирования**: Поддержка уровней: `DEBUG`, `INFO`, `WARN`, `ERROR`.
- **Конфигурируемый уровень**: Управление минимальным уровнем вывода через переменную окружения `LOG_LEVEL` (по умолчанию `DEBUG`).
- **Структурированный вывод**: Логи должны быть информативными и легко читаемыми.

## 2. Архитектурные улучшения

### 2.1. Контекстуальное логирование
Логгер должен принимать не только текстовое сообщение, но и необязательный объект с контекстом.

**Пример:**
```typescript
logger.info("User action executed", { 
  userId: "123", 
  action: "createPost", 
  requestId: "req-456" 
});
```
Это позволит обогащать логи полезной информацией для отладки.

### 2.2. Категории/Теги
Возможность создавать экземпляры логгера с привязанной категорией для упрощения фильтрации.

**Пример:**
```typescript
const dbLogger = logger.withCategory('DATABASE');
dbLogger.info('Connection established'); 
// Вывод: [TIMESTAMP] [INFO] [DATABASE] Connection established
```

### 2.3. Структурированный JSON-вывод
В дополнение к человекочитаемому формату для разработки, логгер должен поддерживать вывод в формате JSON. Это критически важно для интеграции с внешними системами мониторинга (Datadog, Grafana Loki, Sentry).

## 3. Дополнительные методы

### 3.1. Уровень `warn`
Добавить метод `logger.warn()` для ситуаций, которые не являются ошибками, но требуют внимания (например, использование устаревшего API, медленный ответ от внешнего сервиса).

### 3.2. Измерение производительности
Добавить пару методов для простого измерения времени выполнения операций.

**Пример:**
```typescript
logger.time('database-query');
// ... выполнение запроса ...
logger.timeEnd('database-query'); // Автоматически выведет: [PERF] database-query took 125ms
```

## 4. Практические соображения

### 4.1. Вывод логов (Destinations)
Логгер должен поддерживать запись:
- В стандартную консоль (`console.log`, `console.error`).
- В файл (например, `/public/debug.log` или в специальный каталог `/logs`).

### 4.2. Ротация логов
При записи в файл необходимо реализовать механизм ротации, чтобы избежать переполнения диска. Например:
- Создавать новый файл логов каждый день (`app-2025-07-26.log`).
- Автоматически удалять файлы старше N дней (например, 7 дней).

### 4.3. Логирование на клиенте
Для отслеживания ошибок, возникающих в браузере пользователя, необходим отдельный механизм.
- **План**: Создать легковесный клиентский сервис, который будет перехватывать ошибки (`window.onerror`) и отправлять их на специальный API-эндпоинт на сервере (`/api/log-client-error`). Этот эндпоинт, в свою очередь, будет использовать наш серверный логгер для записи ошибки.

## 5. План внедрения

1.  **Этап 1 (База):**
    - Реализовать `logger.ts` с поддержкой уровней (`debug`, `info`, `warn`, `error`).
    - Реализовать запись в `console` и в файл `/public/debug.log`.
    - Добавить управление уровнем через `LOG_LEVEL`.
    - Интегрировать базовые вызовы `logger.info` и `logger.error` в ключевые точки: Server Actions, AIService.

2.  **Этап 2 (Расширение):**
    - Добавить поддержку структурированного контекста.
    - Реализовать методы для измерения производительности (`time`/`timeEnd`).
    - Создать клиентский логгер и API-эндпоинт для сбора ошибок с фронтенда.

3.  **Этап 3 (Зрелость):**
    - Добавить поддержку категорий.
    - Реализовать ротацию логов.
    - Создать страницу в админ-панели для просмотра логов.
    - Добавить опциональный вывод в формате JSON.
