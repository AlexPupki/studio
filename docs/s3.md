# s3.md — Google Cloud Storage (аналог S3) для MVP GTS

Этот файл описывает **минимальную** (MVP) схему хранения на **Google Cloud Storage (GCS)** — аналог Amazon S3 — для загрузки/выдачи медиа и документов без публичного доступа.

## 1) Цели MVP
- Прямые загрузки из браузера/мобилки по **временным ссылкам (Signed URLs v4)**.
- Приватная раздача: скачивание только по временной ссылке.
- Простой набор правил: версияция, CORS, авто‑очистка временных файлов.
- Без CDN на старте (Cloud CDN можно добавить позже без миграции ключей).

## 2) Архитектура и имена
- **Один бакет**: `gts-mvp-media-euw4`
  - Регион: `europe-west4` (Нидерланды, низкая задержка из NL).
  - Префиксы:
    - `uploads/` — прямые загрузки с фронта (в т.ч. `uploads/tmp/`).
    - `media/` — готовый контент для приложения.
- **Доступ**: *Uniform bucket-level access* + *Public access prevention (enforced)*.
- **Шифрование**: по умолчанию (Google-managed). Позже легко перейти на **CMEK (Cloud KMS)**.
- **Версионирование объектов**: включено.

Рекомендуемая структура ключей:
```
uploads/{yyyy}/{mm}/{uuid}.{ext}
media/images/{entity}/{id}/{size}/{hash}.webp
media/videos/{entity}/{id}/{profile}/{hash}.mp4
```

## 3) Создание бакета (gcloud/gsutil)
```bash
PROJECT_ID=<ваш‑проект>
BUCKET=gts-mvp-media-euw4
REGION=europe-west4

# Создать бакет
gcloud storage buckets create gs://$BUCKET --project=$PROJECT_ID --location=$REGION

# Включить единый уровень доступа (UBLA)
gcloud storage buckets update gs://$BUCKET --uniform-bucket-level-access

# Запретить публичный доступ
gcloud storage buckets update gs://$BUCKET --public-access-prevention=enforced

# Включить версионирование
gsutil versioning set on gs://$BUCKET
```

## 4) CORS (для фронта)
Файл `cors.json`:
```json
[
  {
    "origin": ["https://app.gts.example", "http://localhost:3000"],
    "method": ["GET", "PUT", "POST"],
    "responseHeader": ["Content-Type", "ETag", "Location", "x-goog-meta-*"],
    "maxAgeSeconds": 3000
  }
]
```
Применить:
```bash
gsutil cors set cors.json gs://$BUCKET
```

## 5) Lifecycle (авто‑очистка и экономия)
Файл `lifecycle.json`:
```json
{
  "rule": [
    {
      "action": {"type": "Delete"},
      "condition": {"age": 7, "isLive": true, "matchesPrefix": ["uploads/tmp/"]}
    },
    {
      "action": {"type": "SetStorageClass", "storageClass": "NEARLINE"},
      "condition": {"age": 30, "isLive": false}
    },
    {
      "action": {"type": "Delete"},
      "condition": {"age": 365, "isLive": false}
    }
  ]
}
```
Применить:
```bash
gsutil lifecycle set lifecycle.json gs://$BUCKET
```

## 6) Роли и аккаунт сервиса
Создадим сервис‑аккаунт для выдачи подписей и доступов к бакету:
```bash
SA_NAME=gts-presign
SA="$SA_NAME@$PROJECT_ID.iam.gserviceaccount.com"

gcloud iam service-accounts create $SA_NAME --project=$PROJECT_ID

# Доступы минимально необходимые:
# - создавать объекты в uploads/*
# - читать объекты в media/*
# - уметь подписывать URL (signBlob)
gcloud storage buckets add-iam-policy-binding gs://$BUCKET   --member="serviceAccount:$SA" --role="roles/storage.objectCreator"

gcloud storage buckets add-iam-policy-binding gs://$BUCKET   --member="serviceAccount:$SA" --role="roles/storage.objectViewer"

# Для подписи URL c использованием IAMCredentials API:
gcloud projects add-iam-policy-binding $PROJECT_ID   --member="serviceAccount:$SA" --role="roles/iam.serviceAccountTokenCreator"
```

> Примечание: запускать backend лучше под **этим же** сервис‑аккаунтом (Cloud Run/Cloud Functions). Тогда ключи не нужны.

## 7) Мини‑backend: выдача Signed URL (Node.js)
Упрощённый пример (Cloud Run/Functions). Используется **Signed URL v4** для `PUT` (загрузка) и `GET` (скачивание).

```js
// package.json:
// { "type": "module", "dependencies": { "@google-cloud/storage": "^7.11.0", "express": "^4.19.2" } }

import express from "express";
import crypto from "crypto";
import { Storage } from "@google-cloud/storage";

const app = express();
app.use(express.json());

const BUCKET = process.env.BUCKET || "gts-mvp-media-euw4";
const storage = new Storage();
const bucket = storage.bucket(BUCKET);
const MAX_BYTES = parseInt(process.env.MAX_UPLOAD_BYTES || "104857600"); // 100 MB

function makeKey(prefix = "uploads", ext = "") {
  const now = new Date();
  const yyyy = now.getUTCFullYear();
  const mm = String(now.getUTCMonth() + 1).padStart(2, "0");
  const uid = crypto.randomUUID();
  const safeExt = (ext || "").replace(/[^a-zA-Z0-9.]/g, "");
  return `${prefix}/${yyyy}/${mm}/${uid}${safeExt && !safeExt.startsWith(".") ? "." : ""}${safeExt}`;
}

app.post("/sign-upload", async (req, res) => {
  try {
    const { contentType = "application/octet-stream", ext = "", prefix = "uploads" } = req.body || {};
    const key = makeKey(prefix, ext);
    const file = bucket.file(key);

    const [url] = await file.getSignedUrl({
      version: "v4",
      action: "write",
      expires: Date.now() + 5 * 60 * 1000,
      contentType // требуем совпадения типа
    });

    res.json({ url, key, contentType, expiresIn: 300, bucket: BUCKET, maxBytes: MAX_BYTES });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to sign upload URL" });
  }
});

app.get("/sign-download", async (req, res) => {
  try {
    const key = String(req.query.key || "");
    if (!key) return res.status(400).json({ error: "key is required" });

    const file = bucket.file(key);
    const [url] = await file.getSignedUrl({
      version: "v4",
      action: "read",
      expires: Date.now() + 5 * 60 * 1000
    });
    res.json({ url, expiresIn: 300 });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to sign download URL" });
  }
});

app.listen(process.env.PORT || 3001, () => console.log("GCS presign service on"));
```

Развёртывание в **Cloud Run** (простой Dockerfile):
```dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
ENV PORT=8080
CMD ["node", "app.js"]
```

Пример деплоя:
```bash
gcloud run deploy gts-presign-api   --source=.   --region=$REGION   --service-account=$SA   --set-env-vars BUCKET=$BUCKET,MAX_UPLOAD_BYTES=104857600   --allow-unauthenticated
```

## 8) Клиент: загрузка через Signed URL (PUT)
```js
// 1) запросить ссылку
const sign = await fetch("https://<api>/sign-upload", {
  method: "POST",
  headers: {"Content-Type":"application/json"},
  body: JSON.stringify({
    contentType: file.type,       // "image/jpeg"
    ext: '.' + file.name.split('.').pop(), // ".jpg"
    prefix: "media"               // кладём сразу в media/*
  })
}).then(r=>r.json());

// 2) загрузить файл одним PUT
await fetch(sign.url, {
  method: "PUT",
  headers: { "Content-Type": sign.contentType },
  body: file
});

// 3) получить ссылку на скачивание/просмотр
const d = await fetch(`https://<api>/sign-download?key=${encodeURIComponent(sign.key)}`)
  .then(r=>r.json());
// d.url — действует ~5 минут
```

## 9) Безопасность и практика
- **Нет публичных объектов**: всё приватно (Public Access Prevention).
- **Авторизация на backend**: выдаём подписи только авторизованным пользователям/ролям.
- **Контроль типов и размеров**: в backend проверяйте `contentType`, размер (через заголовок `Content-Length` на клиенте) и префикс ключа (`uploads/` или `media/`).
- **Версионирование**: защищает от случайной перезаписи/удаления; старые версии переводим в NEARLINE и удаляем через год (см. lifecycle).
- **Логи**: включите *Cloud Audit Logs* (Data Access) для Storage в проекте и ставьте оповещения в Cloud Monitoring при аномалиях.
- **Дальше по росту**: Cloud CDN (Origin — Cloud Storage), обработка изображений в Cloud Run/Functions, CMEK, Pub/Sub нотификации на загрузки.

## 10) Чек‑лист «готово к бою»
- [ ] Бакет создан в `europe-west4`, UBLA включён, публичный доступ запрещён.
- [ ] Версионирование включено, lifecycle применён.
- [ ] CORS настроен на домены фронта.
- [ ] Сервис‑аккаунт создан, роли выданы (objectCreator, objectViewer, iam.serviceAccountTokenCreator).
- [ ] Backend (Cloud Run) развёрнут, эндпоинты `POST /sign-upload` и `GET /sign-download` работают.
- [ ] Клиент умеет PUT’ить файл по Signed URL и получать read‑ссылку.
