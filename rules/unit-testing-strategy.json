
{
  "name": "Pragmatic Unit & Integration Testing Strategy",
  "purpose": "Обеспечить надежность и предсказуемость ключевых частей приложения, не замедляя разработку избыточными тестами. Мы тестируем бизнес-логику, а не каждую строчку кода.",
  "philosophy": [
    "Тестируем поведение, а не реализацию.",
    "Тесты должны быть быстрыми, надежными и легкими для понимания.",
    "100% покрытие кода — не самоцель. Мы фокусируемся на критически важных путях.",
    "Каждый тест должен проверять один конкретный аспект."
  ],
  "scope": {
    "what_we_test": [
      {
        "target": "Server Actions",
        "why": "Это сердце нашей бизнес-логики. Мы должны быть уверены, что они правильно оркестрируют вызовы сервисов, обрабатывают входные данные и возвращают корректные результаты.",
        "how": "Мокируем (заменяем) фабрики сервисов (`createDbService`, `createYclientsService`), чтобы изолировать экшен от реальных внешних зависимостей. Проверяем, что экшен вызывает нужные методы у моков с правильными параметрами."
      },
      {
        "target": "Service Implementations (Adapters)",
        "why": "Проверяем, что наши адаптеры правильно формируют запросы к внешним API (YCLIENTS) и корректно парсят их ответы.",
        "how": "Мокируем `fetch` или HTTP-клиент, чтобы он возвращал заранее заготовленные ответы от API. Проверяем, что наш сервис правильно обрабатывает эти ответы."
      },
      {
        "target": "Сложные UI-компоненты с состоянием",
        "why": "Если компонент имеет сложную внутреннюю логику (например, форма бронирования с валидацией), мы должны убедиться, что он правильно реагирует на действия пользователя.",
        "how": "Используем React Testing Library для рендеринга компонента и симуляции действий пользователя (клики, ввод текста). Проверяем, что состояние компонента и его отображение меняются корректно."
      }
    ],
    "what_we_dont_test": [
      {
        "target": "Простые UI-компоненты",
        "reason": "Тестировать, что кнопка с текстом 'Привет' действительно отображает 'Привет' — избыточно. Это задача E2E-тестов."
      },
      {
        "target": "Внешние библиотеки (ShadCN, Next.js)",
        "reason": "Мы доверяем тому, что они уже протестированы своими создателями."
      },
      {
        "target": "Фабрики сервисов (`create...Service`)",
        "reason": "Их задача — читать переменные окружения и создавать экземпляр. Эта логика тривиальна и будет проверена интеграционными тестами неявно."
      }
    ]
  },
  "tools": {
    "runner": "Vitest или Jest",
    "ui_testing": "React Testing Library",
    "mocking": "Встроенные в Vitest/Jest функции (`vi.mock`, `jest.mock`)"
  },
  "patterns": {
    "structure": "AAA (Arrange, Act, Assert)",
    "description": "Arrange: Подготовка данных и моков. Act: Вызов тестируемой функции. Assert: Проверка результата."
  },
  "location": {
    "rule": "Тестовые файлы (`*.test.ts` или `*.spec.ts`) должны находиться рядом с тестируемыми файлами. Например, `catalog.actions.ts` и `catalog.actions.test.ts` лежат в одной папке."
  },
  "ci_cd": {
    "integration": "Все тесты должны автоматически запускаться в CI/CD пайплайне (например, через GitHub Actions) при каждом пуше в основные ветки. Сборка не должна проходить, если тесты падают."
  }
}
